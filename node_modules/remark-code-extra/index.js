"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const visit = require("unist-util-visit");
const options_1 = require("./options");
const attacher = (options) => {
    if (!options_1.validateOptions(options))
        throw new Error('Invalid options');
    const transformer = (tree, _file) => __awaiter(this, void 0, void 0, function* () {
        let transformations = [];
        visit(tree, 'code', node => {
            const transform = typeof options.transform === 'function' ? options.transform(node) : options.transform;
            transformations.push(Promise.resolve(transform).then((transform) => __awaiter(this, void 0, void 0, function* () {
                if (transform) {
                    const codeChildren = node.data && node.data.hChildren ||
                        [{
                                type: 'text',
                                value: node.value
                            }];
                    const codeProperties = node.data && node.data.hProperties ||
                        (node.lang ? {
                            className: ['language-' + node.lang]
                        } : {});
                    const n = node;
                    n.type = 'code-extra';
                    if (!n.data)
                        n.data = {};
                    const before = transform.before ? yield Promise.resolve(transform.before) : [];
                    const after = transform.after ? yield Promise.resolve(transform.after) : [];
                    const children = [
                        ...before,
                        {
                            type: 'element',
                            tagName: 'pre',
                            children: [
                                {
                                    type: 'element',
                                    tagName: 'code',
                                    properties: codeProperties,
                                    children: codeChildren
                                }
                            ]
                        },
                        ...after
                    ];
                    n.data.hName = 'div';
                    n.data.hProperties = {
                        className: ['code-extra']
                    };
                    n.data.hChildren = children;
                    if (transform.transform)
                        return transform.transform(n);
                }
            })));
        });
        yield Promise.all(transformations);
        return tree;
    });
    return transformer;
};
attacher.validateOptions = options_1.validateOptions;
module.exports = attacher;
